/**
 * @file bench_layered_codegen_test.cpp
 * @brief Quick test of LayeredCppGenerator output for Hermite E coefficients
 *
 * Compares three implementations:
 * 1. TMP: Original recursive template metaprogramming
 * 2. Layered (hand-written): Hand-written layered CSE
 * 3. Layered (codegen): Generated by LayeredCppGenerator
 *
 * Expected results:
 * - TMP: Fast (0.4 ns at L=0)
 * - Layered hand-written: Slow (2.3 ns at L=0) - 6× overhead
 * - Layered codegen: Fast (0.4-0.5 ns) - should match TMP!
 */

#include <benchmark/benchmark.h>
#include <array>
#include <iostream>
#include <string>
#include <recursum/vectorclass.h>

// Include all three implementations
#include <recursum/mcmd/hermite_e.hpp>               // TMP
#include <recursum/mcmd/hermite_e_layered.hpp>       // Hand-written layered
#include <recursum/generated/hermite_coeff_layered.hpp>  // Codegen layered

using namespace recursum::mcmd;
using namespace recursum::mcmd::layered;

// =============================================================================
// Test Geometry Parameters
// =============================================================================

struct TestParams {
    Vec8d PA, PB, p;

    TestParams() {
        // Simple test geometry
        PA = Vec8d(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8);
        PB = Vec8d(-0.1, -0.2, -0.3, -0.4, -0.5, -0.6, -0.7, -0.8);
        p = Vec8d(1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2);
    }
};

// =============================================================================
// Benchmark: Single Value Access (nA=2, nB=1, t=2)
// =============================================================================

static void BM_HermiteE_TMP_Single(benchmark::State& state) {
    TestParams params;

    for (auto _ : state) {
        auto result = HermiteE<2, 1, 2>::compute(params.PA, params.PB, params.p);
        benchmark::DoNotOptimize(result);
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 0;  // TMP
    state.counters["nA"] = 2;
    state.counters["nB"] = 1;
    state.counters["t"] = 2;
}

static void BM_HermiteE_LayeredHandwritten_Single(benchmark::State& state) {
    TestParams params;

    for (auto _ : state) {
        auto result = HermiteEOpt<2, 1, 2>::compute(params.PA, params.PB, params.p);
        benchmark::DoNotOptimize(result);
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 1;  // Layered hand-written
    state.counters["nA"] = 2;
    state.counters["nB"] = 1;
    state.counters["t"] = 2;
}

static void BM_HermiteE_LayeredCodegen_Single(benchmark::State& state) {
    TestParams params;

    for (auto _ : state) {
        // Use generated layered code (from mcmd_hermite namespace)
        auto result = mcmd_hermite::HermiteECoeff<2, 1, 2>::compute(params.PA, params.PB, params.p);
        benchmark::DoNotOptimize(result);
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 2;  // Layered codegen
    state.counters["nA"] = 2;
    state.counters["nB"] = 1;
    state.counters["t"] = 2;
}

// =============================================================================
// Benchmark: All Values at Once (nA=2, nB=1, all t)
// =============================================================================

static void BM_HermiteE_LayeredHandwritten_AllT(benchmark::State& state) {
    TestParams params;

    for (auto _ : state) {
        auto layer = HermiteELayer<2, 1>::compute(params.PA, params.PB, params.p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 1;  // Layered hand-written
    state.counters["nA"] = 2;
    state.counters["nB"] = 1;
    state.counters["n_values"] = 4;  // t = 0, 1, 2, 3
}

static void BM_HermiteE_LayeredCodegen_AllT(benchmark::State& state) {
    TestParams params;
    Vec8d layer[4];  // nA + nB + 1 = 4 values

    for (auto _ : state) {
        mcmd_hermite::HermiteECoeffLayer<2, 1>::compute(layer, params.PA, params.PB, params.p);
        benchmark::DoNotOptimize(layer);
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 2;  // Layered codegen
    state.counters["nA"] = 2;
    state.counters["nB"] = 1;
    state.counters["n_values"] = 4;  // t = 0, 1, 2, 3
}

// =============================================================================
// Register Benchmarks
// =============================================================================

// Single value access (API compatibility test)
BENCHMARK(BM_HermiteE_TMP_Single)->Name("HermiteE/Single/TMP")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredHandwritten_Single)->Name("HermiteE/Single/LayeredHandwritten")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen_Single)->Name("HermiteE/Single/LayeredCodegen")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// All values at once (layer computation)
BENCHMARK(BM_HermiteE_LayeredHandwritten_AllT)->Name("HermiteE/AllT/LayeredHandwritten")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen_AllT)->Name("HermiteE/AllT/LayeredCodegen")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// =============================================================================
// Main
// =============================================================================

int main(int argc, char** argv) {
    std::cout << "\n" << std::string(80, '=') << "\n";
    std::cout << "LAYERED CODEGEN VALIDATION BENCHMARK\n";
    std::cout << "Hermite E Coefficients: TMP vs Layered Hand-written vs Layered Codegen\n";
    std::cout << std::string(80, '=') << "\n\n";

    std::cout << "Test case: nA=2, nB=1, t=2 (4 coefficients total)\n\n";

    std::cout << "Expected results:\n";
    std::cout << "  TMP:                  ~0.4 ns (fast)\n";
    std::cout << "  Layered hand-written: ~2.3 ns (slow - 6× overhead)\n";
    std::cout << "  Layered codegen:      ~0.4-0.5 ns (FAST - should match TMP!)\n";
    std::cout << "\n";
    std::cout << "If codegen matches TMP, we've successfully eliminated the 6× overhead!\n";
    std::cout << std::string(80, '=') << "\n\n";

    benchmark::Initialize(&argc, argv);
    benchmark::RunSpecifiedBenchmarks();

    return 0;
}
