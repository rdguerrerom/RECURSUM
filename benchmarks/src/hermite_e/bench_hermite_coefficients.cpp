/**
 * @file bench_hermite_coefficients.cpp
 * @brief Benchmark: Hermite Expansion Coefficients E_N^{i,j} for ERI Preparation
 *
 * In the McMurchie-Davidson algorithm, ERIs require ALL Hermite expansion
 * coefficients E_N^{i,j} for N = 0, 1, ..., i+j for each shell pair.
 *
 * This benchmark measures the time to compute and STORE all coefficients
 * for later contraction with Coulomb auxiliary integrals R_{tuv}.
 *
 * The timed operation for shell pair (nA, nB) is:
 *   layer[N] = E_N^{nA,nB}  for N = 0, 1, ..., nA+nB
 *
 * NOT the artificial sum used in previous benchmarks.
 *
 * References:
 *   McMurchie & Davidson, J. Comput. Phys. 26 (1978) 218-231
 *   See benchmarks/McMD_METHODOLOGY.md for detailed algorithm description
 */

#include <benchmark/benchmark.h>
#include <array>
#include <iostream>
#include <recursum/mcmd/hermite_e.hpp>
#include <recursum/mcmd/hermite_e_layered.hpp>
#include <recursum/generated/hermite_coeff_layered.hpp>
#include "hermite_e_symbolic.hpp"
#include "benchmark_common.hpp"

using namespace recursum::benchmark;
using namespace recursum::mcmd;

// Maximum L supported
constexpr int MAX_L = 8;
constexpr int MAX_COEFFS = MAX_L + 1;  // For L=8, need 9 coefficients (N=0..8)

// =============================================================================
// Original TMP: Compute each E_N separately and store
// =============================================================================

template<int nA, int nB>
static void BM_HermiteE_TMP(benchmark::State& state) {
    GeometryParams params(42);
    constexpr int L = nA + nB;
    std::array<Vec8d, MAX_COEFFS> layer;

    for (auto _ : state) {
        // Compute each E_N^{nA,nB} separately and store
        if constexpr (L >= 0) layer[0] = HermiteE<nA, nB, 0>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 1) layer[1] = HermiteE<nA, nB, 1>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 2) layer[2] = HermiteE<nA, nB, 2>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 3) layer[3] = HermiteE<nA, nB, 3>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 4) layer[4] = HermiteE<nA, nB, 4>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 5) layer[5] = HermiteE<nA, nB, 5>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 6) layer[6] = HermiteE<nA, nB, 6>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 7) layer[7] = HermiteE<nA, nB, 7>::compute(params.PA[0], params.PB[0], params.p);
        if constexpr (L >= 8) layer[8] = HermiteE<nA, nB, 8>::compute(params.PA[0], params.PB[0], params.p);

        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 0;  // Original TMP
    state.counters["nA"] = nA;
    state.counters["nB"] = nB;
    state.counters["L"] = L;
    state.counters["n_coeffs"] = L + 1;
}

// =============================================================================
// Layered CSE: Compute all E_N at once with common subexpression elimination
// =============================================================================

template<int nA, int nB>
static void BM_HermiteE_Layered(benchmark::State& state) {
    GeometryParams params(42);
    constexpr int L = nA + nB;

    for (auto _ : state) {
        // Compute all E_N^{nA,nB} in one layer computation
        auto layer = layered::HermiteELayer<nA, nB>::compute(params.PA[0], params.PB[0], params.p);

        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 1;  // Layered CSE
    state.counters["nA"] = nA;
    state.counters["nB"] = nB;
    state.counters["L"] = L;
    state.counters["n_coeffs"] = L + 1;
}

// =============================================================================
// Layered Codegen: Generated by LayeredCppGenerator with RECURSUM_FORCEINLINE
// =============================================================================

template<int nA, int nB>
static void BM_HermiteE_LayeredCodegen(benchmark::State& state) {
    GeometryParams params(42);
    constexpr int L = nA + nB;
    Vec8d layer[L + 1];  // Exact-sized buffer

    for (auto _ : state) {
        // Use generated layered code (output parameter, zero-copy)
        mcmd_hermite::HermiteECoeffLayer<nA, nB>::compute(layer, params.PA[0], params.PB[0], params.p);

        benchmark::DoNotOptimize(layer);
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 3;  // Layered Codegen
    state.counters["nA"] = nA;
    state.counters["nB"] = nB;
    state.counters["L"] = L;
    state.counters["n_coeffs"] = L + 1;
}

// =============================================================================
// Symbolic: Compute each coefficient from closed-form polynomial and store
// =============================================================================

// Helper macro for symbolic coefficient computation
#define STORE_SYM(NA, NB, N) \
    layer[N] = recursum::symbolic::hermite_e_symbolic_##NA##_##NB##_##N(params.PA[0], params.PB[0], params.one_over_2p)

template<int nA, int nB>
static void BM_HermiteE_Symbolic(benchmark::State& state) {
    GeometryParams params(42);
    constexpr int L = nA + nB;
    std::array<Vec8d, MAX_COEFFS> layer;

    for (auto _ : state) {
        // This requires specialization for each (nA, nB) combination
        // Will be implemented via macro expansion below
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }

    state.counters["impl"] = 2;  // Symbolic
    state.counters["nA"] = nA;
    state.counters["nB"] = nB;
    state.counters["L"] = L;
    state.counters["n_coeffs"] = L + 1;
}

// Specialized symbolic benchmarks for each shell pair
static void BM_HermiteE_Symbolic_0_0(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_0_0_0(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 0; state.counters["nB"] = 0;
    state.counters["L"] = 0; state.counters["n_coeffs"] = 1;
}

static void BM_HermiteE_Symbolic_0_1(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_0_1_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_0_1_1(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 0; state.counters["nB"] = 1;
    state.counters["L"] = 1; state.counters["n_coeffs"] = 2;
}

static void BM_HermiteE_Symbolic_1_1(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_1_1_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_1_1_1(params.PA[0], params.PB[0], params.one_over_2p);
        layer[2] = recursum::symbolic::hermite_e_symbolic_1_1_2(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 1; state.counters["nB"] = 1;
    state.counters["L"] = 2; state.counters["n_coeffs"] = 3;
}

static void BM_HermiteE_Symbolic_0_2(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_0_2_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_0_2_1(params.PA[0], params.PB[0], params.one_over_2p);
        layer[2] = recursum::symbolic::hermite_e_symbolic_0_2_2(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 0; state.counters["nB"] = 2;
    state.counters["L"] = 2; state.counters["n_coeffs"] = 3;
}

static void BM_HermiteE_Symbolic_1_2(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_1_2_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_1_2_1(params.PA[0], params.PB[0], params.one_over_2p);
        layer[2] = recursum::symbolic::hermite_e_symbolic_1_2_2(params.PA[0], params.PB[0], params.one_over_2p);
        layer[3] = recursum::symbolic::hermite_e_symbolic_1_2_3(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 1; state.counters["nB"] = 2;
    state.counters["L"] = 3; state.counters["n_coeffs"] = 4;
}

static void BM_HermiteE_Symbolic_2_2(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_2_2_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_2_2_1(params.PA[0], params.PB[0], params.one_over_2p);
        layer[2] = recursum::symbolic::hermite_e_symbolic_2_2_2(params.PA[0], params.PB[0], params.one_over_2p);
        layer[3] = recursum::symbolic::hermite_e_symbolic_2_2_3(params.PA[0], params.PB[0], params.one_over_2p);
        layer[4] = recursum::symbolic::hermite_e_symbolic_2_2_4(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 2; state.counters["nB"] = 2;
    state.counters["L"] = 4; state.counters["n_coeffs"] = 5;
}

static void BM_HermiteE_Symbolic_3_3(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_3_3_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_3_3_1(params.PA[0], params.PB[0], params.one_over_2p);
        layer[2] = recursum::symbolic::hermite_e_symbolic_3_3_2(params.PA[0], params.PB[0], params.one_over_2p);
        layer[3] = recursum::symbolic::hermite_e_symbolic_3_3_3(params.PA[0], params.PB[0], params.one_over_2p);
        layer[4] = recursum::symbolic::hermite_e_symbolic_3_3_4(params.PA[0], params.PB[0], params.one_over_2p);
        layer[5] = recursum::symbolic::hermite_e_symbolic_3_3_5(params.PA[0], params.PB[0], params.one_over_2p);
        layer[6] = recursum::symbolic::hermite_e_symbolic_3_3_6(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 3; state.counters["nB"] = 3;
    state.counters["L"] = 6; state.counters["n_coeffs"] = 7;
}

static void BM_HermiteE_Symbolic_4_4(benchmark::State& state) {
    GeometryParams params(42);
    std::array<Vec8d, MAX_COEFFS> layer;
    for (auto _ : state) {
        layer[0] = recursum::symbolic::hermite_e_symbolic_4_4_0(params.PA[0], params.PB[0], params.one_over_2p);
        layer[1] = recursum::symbolic::hermite_e_symbolic_4_4_1(params.PA[0], params.PB[0], params.one_over_2p);
        layer[2] = recursum::symbolic::hermite_e_symbolic_4_4_2(params.PA[0], params.PB[0], params.one_over_2p);
        layer[3] = recursum::symbolic::hermite_e_symbolic_4_4_3(params.PA[0], params.PB[0], params.one_over_2p);
        layer[4] = recursum::symbolic::hermite_e_symbolic_4_4_4(params.PA[0], params.PB[0], params.one_over_2p);
        layer[5] = recursum::symbolic::hermite_e_symbolic_4_4_5(params.PA[0], params.PB[0], params.one_over_2p);
        layer[6] = recursum::symbolic::hermite_e_symbolic_4_4_6(params.PA[0], params.PB[0], params.one_over_2p);
        layer[7] = recursum::symbolic::hermite_e_symbolic_4_4_7(params.PA[0], params.PB[0], params.one_over_2p);
        layer[8] = recursum::symbolic::hermite_e_symbolic_4_4_8(params.PA[0], params.PB[0], params.one_over_2p);
        benchmark::DoNotOptimize(layer.data());
        benchmark::ClobberMemory();
    }
    state.counters["impl"] = 2; state.counters["nA"] = 4; state.counters["nB"] = 4;
    state.counters["L"] = 8; state.counters["n_coeffs"] = 9;
}

// =============================================================================
// Register Benchmarks
// =============================================================================

// ss (L=0): 1 coefficient
BENCHMARK(BM_HermiteE_TMP<0, 0>)->Name("HermiteE/TMP/ss")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<0, 0>)->Name("HermiteE/Layered/ss")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<0, 0>)->Name("HermiteE/LayeredCodegen/ss")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_0_0)->Name("HermiteE/Symbolic/ss")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// sp (L=1): 2 coefficients
BENCHMARK(BM_HermiteE_TMP<0, 1>)->Name("HermiteE/TMP/sp")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<0, 1>)->Name("HermiteE/Layered/sp")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<0, 1>)->Name("HermiteE/LayeredCodegen/sp")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_0_1)->Name("HermiteE/Symbolic/sp")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// pp (L=2): 3 coefficients
BENCHMARK(BM_HermiteE_TMP<1, 1>)->Name("HermiteE/TMP/pp")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<1, 1>)->Name("HermiteE/Layered/pp")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<1, 1>)->Name("HermiteE/LayeredCodegen/pp")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_1_1)->Name("HermiteE/Symbolic/pp")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// sd (L=2): 3 coefficients
BENCHMARK(BM_HermiteE_TMP<0, 2>)->Name("HermiteE/TMP/sd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<0, 2>)->Name("HermiteE/Layered/sd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<0, 2>)->Name("HermiteE/LayeredCodegen/sd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_0_2)->Name("HermiteE/Symbolic/sd")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// pd (L=3): 4 coefficients
BENCHMARK(BM_HermiteE_TMP<1, 2>)->Name("HermiteE/TMP/pd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<1, 2>)->Name("HermiteE/Layered/pd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<1, 2>)->Name("HermiteE/LayeredCodegen/pd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_1_2)->Name("HermiteE/Symbolic/pd")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// dd (L=4): 5 coefficients
BENCHMARK(BM_HermiteE_TMP<2, 2>)->Name("HermiteE/TMP/dd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<2, 2>)->Name("HermiteE/Layered/dd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<2, 2>)->Name("HermiteE/LayeredCodegen/dd")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_2_2)->Name("HermiteE/Symbolic/dd")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// ff (L=6): 7 coefficients
BENCHMARK(BM_HermiteE_TMP<3, 3>)->Name("HermiteE/TMP/ff")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<3, 3>)->Name("HermiteE/Layered/ff")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<3, 3>)->Name("HermiteE/LayeredCodegen/ff")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_3_3)->Name("HermiteE/Symbolic/ff")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// gg (L=8): 9 coefficients
BENCHMARK(BM_HermiteE_TMP<4, 4>)->Name("HermiteE/TMP/gg")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Layered<4, 4>)->Name("HermiteE/Layered/gg")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_LayeredCodegen<4, 4>)->Name("HermiteE/LayeredCodegen/gg")->Unit(benchmark::kNanosecond)->MinTime(1.0);
BENCHMARK(BM_HermiteE_Symbolic_4_4)->Name("HermiteE/Symbolic/gg")->Unit(benchmark::kNanosecond)->MinTime(1.0);

// =============================================================================
// Main
// =============================================================================

int main(int argc, char** argv) {
    std::cout << "\n" << std::string(80, '=') << "\n";
    std::cout << "HERMITE EXPANSION COEFFICIENTS BENCHMARK\n";
    std::cout << "McMurchie-Davidson E_N^{i,j} for ERI Preparation\n";
    std::cout << std::string(80, '=') << "\n\n";

    std::cout << "Timed operation: Compute and STORE all E_N^{nA,nB} for N = 0, 1, ..., nA+nB\n";
    std::cout << "This is the preparation step before ERI contraction with R_{tuv}\n\n";

    std::cout << "Implementations:\n";
    std::cout << "  TMP:            Original recursive template metaprogramming\n";
    std::cout << "  Layered:        Hand-written layer-by-layer with CSE\n";
    std::cout << "  LayeredCodegen: Generated by LayeredCppGenerator (RECURSUM_FORCEINLINE)\n";
    std::cout << "  Symbolic:       SymPy-generated closed-form polynomials\n";
    std::cout << std::string(80, '=') << "\n\n";

    benchmark::Initialize(&argc, argv);
    benchmark::RunSpecifiedBenchmarks();

    return 0;
}
