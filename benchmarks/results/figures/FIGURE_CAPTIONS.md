# Figure Captions for McMurchie-Davidson Benchmark Results

**Publication-ready figure captions following scientific standards**

---

## Figure 1: Hermite Expansion Coefficients Comparison

**Figure 1. LayeredCodegen automatic code generation achieves optimal performance for Hermite expansion coefficients.**

Performance comparison of four implementations for computing Hermite expansion coefficients E across shell pairs (ss, sp, pp, sd, pd, dd, ff, gg) with increasing total angular momentum L. The NEW LayeredCodegen implementation (red diamonds, solid line) generated by LayeredCppGenerator significantly outperforms the hand-written Layered approach (orange squares, dashed line) by 6-10× across all shell pairs, while matching or exceeding the TMP baseline (blue circles, solid line). The Symbolic implementation (green triangles, dash-dot line) using SymPy-generated closed-form expressions shows intermediate performance. Y-axis shows execution time in nanoseconds on a logarithmic scale. Error bars represent standard deviation over 100 repetitions with minimum 1.0 second total execution time per benchmark. All measurements performed on Intel system with 28 CPUs at 5.3 GHz under controlled load conditions.

**Key finding**: LayeredCodegen (0.207 ns for ss shell) is 1.9× faster than TMP (0.403 ns) and 9.8× faster than hand-written Layered (2.018 ns), demonstrating that automatic code generation with proper optimizations (output parameters, RECURSUM_FORCEINLINE, exact-sized buffers) can exceed hand-optimized implementations.

---

## Figure 2: Hermite Coefficients Scaling with Angular Momentum

**Figure 2. All implementations show exponential scaling with total angular momentum L.**

Performance scaling of Hermite expansion coefficient computation as a function of total angular momentum L = nA + nB. Data points represent averages over all shell pairs with the same L value, with error bars showing propagated uncertainties. All four implementations exhibit similar scaling behavior on the logarithmic plot, but LayeredCodegen (red) consistently maintains the lowest execution time across the entire L range (0-6). The parallel scaling curves demonstrate that the relative performance advantage of LayeredCodegen is maintained at higher angular momenta, critical for computational quantum chemistry applications requiring high-order integrals.

---

## Figure 3: LayeredCodegen Speedup over Hand-written Implementation

**Figure 3. LayeredCodegen eliminates computational overhead from hand-written layer-by-layer implementation.**

Direct speedup comparison showing the ratio of execution times between hand-written Layered and automatically generated LayeredCodegen implementations across shell pairs. Bar heights indicate speedup factors (Layered time / LayeredCodegen time), with values labeled above each bar. The consistent 6-10× speedup across all shell pairs (average 9.0×) demonstrates that automatic code generation successfully eliminates overhead present in the hand-written implementation through systematic application of optimization patterns: output parameters instead of return values, guaranteed function inlining via RECURSUM_FORCEINLINE, and exact-sized stack buffers eliminating dynamic allocation overhead. Dashed reference line at 1.0 indicates no speedup.

**Implications**: This result validates the LayeredCppGenerator approach for automatic high-performance code generation in computational chemistry applications, where hand-optimization traditionally dominates but is labor-intensive and error-prone.

---

## Figure 4: Coulomb Auxiliary Integrals Comparison

**Figure 4. Coulomb auxiliary integrals R_tuv show minimal implementation differences at low angular momentum.**

Performance comparison of TMP (blue circles) and hand-written Layered (orange squares) implementations for computing Coulomb auxiliary integrals R_tuv as a function of total angular momentum L_total (0-8). Both implementations show similar performance across the L range, with execution times spanning three orders of magnitude from ~0.4 ns at L=0 to ~200 ns at L=8. The near-identical performance suggests that the Coulomb integral recurrence relations, which differ structurally from Hermite expansion coefficients, may already be near-optimally implemented in both approaches. Y-axis uses logarithmic scale to capture the wide dynamic range. Error bars represent standard deviation over 100 repetitions.

---

## Figure 5: Coulomb Auxiliary Integrals Scaling Analysis

**Figure 5. Coulomb auxiliary integrals exhibit favorable scaling with problem size.**

Scaling behavior of Coulomb auxiliary integral computation as a function of the number of integrals computed (tetrahedral(L) = (L+1)(L+2)(L+3)/6). Both axes use logarithmic scales to reveal the scaling exponent. The approximately linear relationship on the log-log plot indicates polynomial scaling, consistent with the theoretical complexity of the recurrence relations. The minimal gap between TMP and Layered implementations persists across the full range (1 to 165 integrals), reinforcing the conclusion from Figure 4 that both approaches are well-optimized for this computation pattern.

**Technical note**: The number of integrals follows the tetrahedral number sequence, reflecting the three-dimensional nature (t, u, v indices) of the auxiliary integral array for McMurchie-Davidson-based electron repulsion integral evaluation.

---

## General Notes for All Figures

**Experimental Setup:**
- Platform: Linux system with Intel CPUs (28 cores, 5.3 GHz)
- Compiler: GCC/Clang with -O3 optimization
- Benchmark framework: Google Benchmark with 100 repetitions per configuration
- Minimum execution time: 1.0 second per benchmark for statistical reliability
- Cache configuration: L1 data (48 KB), L1 instruction (32 KB), L2 unified (2 MB), L3 unified (33 MB)

**Implementation Details:**
- TMP (impl=0): Template metaprogramming with compile-time recursion unrolling
- Layered (impl=1): Hand-written layer-by-layer evaluation with common subexpression elimination
- Symbolic (impl=2): SymPy-generated closed-form algebraic expressions
- LayeredCodegen (impl=3): Automatically generated by LayeredCppGenerator with RECURSUM_FORCEINLINE

**Visualization Standards:**
- All plots use colorblind-safe Okabe-Ito color palette
- Distinct markers and line styles provide redundant encoding
- Error bars show ±1 standard deviation
- Time axes use base-10 logarithmic scale (except speedup plot)
- Figures sized for Nature journal single/1.5-column format
- 300 DPI resolution for publication quality
- Both PNG (preview) and PDF (vector, publication) formats provided

**Statistical Reliability:**
Error bars represent standard deviation (σ) calculated from 100 independent repetitions of each benchmark configuration. The high repetition count and minimum execution time ensure measurement precision below 1% relative uncertainty for most configurations.

---

## Usage in Publications

When citing these results:

1. Reference the RECURSUM library and LayeredCppGenerator tool
2. Acknowledge Google Benchmark framework
3. State that "Error bars represent standard deviation over 100 repetitions"
4. For speedup comparisons, clarify "Speedup = T_baseline / T_optimized"
5. Specify compiler optimization level (-O3) and target architecture

**Suggested acknowledgment:**
"Benchmarks were performed using Google Benchmark framework with 100 repetitions per configuration on an Intel system (28 cores @ 5.3 GHz). Figures generated using matplotlib with colorblind-safe Okabe-Ito palette following scientific visualization best practices."
