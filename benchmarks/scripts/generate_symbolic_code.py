#!/usr/bin/env python3
"""
Generate symbolic (unrolled) Hermite E coefficient code for benchmarking.

This script generates C++ code with explicit, unrolled expressions for
Hermite expansion coefficients. The generated code represents what a
symbolic algebra system (like SymPy) would produce after optimization.

Output: benchmarks/symbolic_generated/hermite_e_symbolic.hpp
"""

import sympy as sp
from sympy import symbols, ccode, simplify, expand
from typing import Dict, Tuple, List
import os


def generate_hermite_e_recurrence(max_nA: int, max_nB: int) -> Dict[Tuple[int, int, int], sp.Expr]:
    """
    Generate symbolic expressions for all Hermite E coefficients.

    Uses the Helgaker-Taylor (1992) recurrence:
        E^{i+1,j}_t = (1/2p) * E^{i,j}_{t-1} + PA * E^{i,j}_t + (t+1) * E^{i,j}_{t+1}

    For t=0:
        E^{i+1,j}_0 = PA * E^{i,j}_0 + E^{i,j}_1
    """
    PA, PB, one_over_2p = symbols('PA PB one_over_2p', real=True)

    # Storage for all expressions
    E: Dict[Tuple[int, int, int], sp.Expr] = {}

    # Base case: E^{0,0}_0 = 1
    E[(0, 0, 0)] = sp.Integer(1)

    def get_E(nA: int, nB: int, t: int) -> sp.Expr:
        """Get E coefficient, returning 0 for invalid indices."""
        if nA < 0 or nB < 0 or t < 0 or t > nA + nB:
            return sp.Integer(0)
        return E.get((nA, nB, t), sp.Integer(0))

    # Build A-side (nB = 0)
    for i in range(1, max_nA + 1):
        for t in range(i + 1):
            if t == 0:
                E[(i, 0, 0)] = PA * get_E(i-1, 0, 0) + get_E(i-1, 0, 1)
            else:
                E[(i, 0, t)] = (one_over_2p * get_E(i-1, 0, t-1)
                               + PA * get_E(i-1, 0, t)
                               + (t + 1) * get_E(i-1, 0, t+1))

    # Build B-side (nA = 0)
    for j in range(1, max_nB + 1):
        for t in range(j + 1):
            if t == 0:
                E[(0, j, 0)] = PB * get_E(0, j-1, 0) + get_E(0, j-1, 1)
            else:
                E[(0, j, t)] = (one_over_2p * get_E(0, j-1, t-1)
                               + PB * get_E(0, j-1, t)
                               + (t + 1) * get_E(0, j-1, t+1))

    # Build mixed (nA > 0, nB > 0)
    for i in range(1, max_nA + 1):
        for j in range(1, max_nB + 1):
            for t in range(i + j + 1):
                if t == 0:
                    E[(i, j, 0)] = PA * get_E(i-1, j, 0) + get_E(i-1, j, 1)
                else:
                    E[(i, j, t)] = (one_over_2p * get_E(i-1, j, t-1)
                                   + PA * get_E(i-1, j, t)
                                   + (t + 1) * get_E(i-1, j, t+1))

    # Expand all expressions to get explicit polynomial form
    for key in E:
        E[key] = expand(E[key])

    return E


def expr_to_cpp(expr: sp.Expr) -> str:
    """Convert SymPy expression to C++ code with Vec8d operations."""
    code = ccode(expr)
    # Replace pow with explicit multiplications for small powers
    code = code.replace('pow(PA, 2)', '(PA*PA)')
    code = code.replace('pow(PB, 2)', '(PB*PB)')
    code = code.replace('pow(one_over_2p, 2)', '(one_over_2p*one_over_2p)')
    code = code.replace('pow(PA, 3)', '(PA*PA*PA)')
    code = code.replace('pow(PB, 3)', '(PB*PB*PB)')
    code = code.replace('pow(one_over_2p, 3)', '(one_over_2p*one_over_2p*one_over_2p)')
    code = code.replace('pow(PA, 4)', '((PA*PA)*(PA*PA))')
    code = code.replace('pow(PB, 4)', '((PB*PB)*(PB*PB))')
    code = code.replace('pow(PA, 5)', '((PA*PA)*(PA*PA)*PA)')
    code = code.replace('pow(PB, 5)', '((PB*PB)*(PB*PB)*PB)')
    code = code.replace('pow(PA, 6)', '((PA*PA*PA)*(PA*PA*PA))')
    code = code.replace('pow(PB, 6)', '((PB*PB*PB)*(PB*PB*PB))')
    return code


def generate_cpp_code(expressions: Dict[Tuple[int, int, int], sp.Expr]) -> str:
    """Generate C++ header with all coefficient functions."""

    cpp = '''/**
 * @file hermite_e_symbolic.hpp
 * @brief Symbolically-generated Hermite E coefficients (expanded form)
 *
 * AUTO-GENERATED by generate_symbolic_code.py
 * DO NOT EDIT MANUALLY
 *
 * This file contains unrolled expressions for Hermite expansion
 * coefficients E^{nA,nB}_t. Generated using SymPy.
 */

#pragma once

#ifndef RECURSUM_VEC_TYPE
#include <recursum/vectorclass.h>
#endif

namespace recursum {
namespace symbolic {

'''

    # Sort by (nA, nB, t)
    sorted_keys = sorted(expressions.keys())

    for key in sorted_keys:
        nA, nB, t = key
        expr = expressions[key]

        cpp += f'''/**
 * @brief Symbolic E^{{{nA},{nB}}}_{t}
 */
inline Vec8d hermite_e_symbolic_{nA}_{nB}_{t}(Vec8d PA, Vec8d PB, Vec8d one_over_2p) {{
    return {expr_to_cpp(expr)};
}}

'''

    # Add dispatcher function
    cpp += '''/**
 * @brief Runtime dispatcher for symbolic Hermite E coefficients
 */
inline Vec8d dispatch_hermite_e_symbolic(int nA, int nB, int t,
                                          Vec8d PA, Vec8d PB, Vec8d one_over_2p) {
'''

    for key in sorted_keys:
        nA, nB, t = key
        cpp += f'    if (nA == {nA} && nB == {nB} && t == {t}) return hermite_e_symbolic_{nA}_{nB}_{t}(PA, PB, one_over_2p);\n'

    cpp += '''    return Vec8d(0.0);  // Invalid indices
}

} // namespace symbolic
} // namespace recursum
'''

    return cpp


def main():
    import argparse
    parser = argparse.ArgumentParser(description='Generate symbolic Hermite E code')
    parser.add_argument('--max-L', type=int, default=3,
                        help='Maximum angular momentum (default: 3 for f-type)')
    parser.add_argument('--output', type=str,
                        default='../symbolic_generated/hermite_e_symbolic.hpp',
                        help='Output file path')
    args = parser.parse_args()

    max_L = args.max_L
    print(f"Generating symbolic Hermite E coefficients for L=0..{max_L}")

    # Generate expressions
    expressions = generate_hermite_e_recurrence(max_L, max_L)
    print(f"Generated {len(expressions)} coefficient expressions")

    # Generate C++ code
    cpp_code = generate_cpp_code(expressions)

    # Write output
    output_path = os.path.join(os.path.dirname(__file__), args.output)
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w') as f:
        f.write(cpp_code)

    print(f"Generated {output_path}")
    print(f"Total expressions: {len(expressions)}")


if __name__ == '__main__':
    main()
